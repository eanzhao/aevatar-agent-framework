# Aevatar Agent Framework - å·¥å…·ç³»ç»Ÿè®¾è®¡

 ## ğŸ¯ å·¥å…·ç³»ç»Ÿæ¦‚è¿°

 å·¥å…·ç³»ç»Ÿæ˜¯Aevatar Agent Frameworkçš„æ ¸å¿ƒç»„ä»¶ä¹‹ä¸€ï¼Œå®ƒä¸ºAIä»£ç†æä¾›äº†**å®‰å…¨ã€å¯æ‰©å±•ã€ç±»å‹å®‰å…¨**çš„å¤–éƒ¨èƒ½åŠ›è°ƒç”¨æœºåˆ¶ã€‚å·¥å…·ç³»ç»Ÿé‡‡ç”¨æ’ä»¶å¼æ¶æ„ï¼Œæ”¯æŒè¿è¡Œæ—¶åŠ¨æ€å‘ç°å’Œæ³¨å†Œå·¥å…·ï¼ŒåŒæ—¶æ
 ä¾›å®Œå–„çš„å®‰å…¨éªŒè¯å’Œè®¿é—®æ§åˆ¶æœºåˆ¶ã€‚

 ## ğŸ—ï¸ å·¥å…·ç³»ç»Ÿæ¶æ„

 ```
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                å·¥å…·ä½¿ç”¨å±‚                                â”‚
 â”‚           AIä»£ç†è°ƒç”¨å·¥å…·                                  â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚                å·¥å…·ç®¡ç†å±‚                                â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
 â”‚  â”‚  ToolManager  â”‚  ToolRegistry  â”‚  ToolDiscovery  â”‚   â”‚
 â”‚  â”‚  ToolValidatorâ”‚  ToolExecutor   â”‚  ToolContext    â”‚   â”‚
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚                å·¥å…·å®ç°å±‚                                â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
 â”‚  â”‚  Core Tools  â”‚Custom Tools  â”‚  External Tools    â”‚   â”‚
 â”‚  â”‚(Built-in)    â”‚(User Defined)â”‚  (API Integration) â”‚   â”‚
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚                å®‰å…¨éªŒè¯å±‚                                â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
 â”‚  â”‚  Parameter   â”‚  Access      â”‚  Rate Limiting     â”‚   â”‚
 â”‚  â”‚  Validation  â”‚  Control     â”‚  & Throttling       â”‚   â”‚
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚                æ‰§è¡Œå¼•æ“å±‚                                â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
 â”‚  â”‚  Sync Exec   â”‚  Async Exec  â”‚  Parallel Exec     â”‚   â”‚
 â”‚  â”‚  Pipeline    â”‚  Retry Logic â”‚  Circuit Breaker   â”‚   â”‚
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 ```

 ## ğŸ”§ æ ¸å¿ƒæ¥å£è®¾è®¡

 ### 1. åŸºç¡€å·¥å…·æ¥å£

 ```csharp
 public interface IAevatarTool
 {
     // å·¥å…·æ ‡è¯†
     string Name { get; }
     string Description { get; }
     string Category { get; }
     string Version { get; }

     // å·¥å…·å®šä¹‰
     ToolDefinition Definition { get; }

     // æ‰§è¡Œæ–¹æ³•
     Task<ToolResult> ExecuteAsync(
         Dictionary<string, object> parameters,
         CancellationToken cancellationToken = default);

     // éªŒè¯æ–¹æ³•
     Task<ValidationResult> ValidateParametersAsync(Dictionary<string, object> parameters);
     Task<bool> HasPermissionAsync(IPrincipal principal, Dictionary<string, object> parameters);

     // ç”Ÿå‘½å‘¨æœŸ
     Task InitializeAsync(CancellationToken cancellationToken = default);
     Task CleanupAsync(CancellationToken cancellationToken = default);
 }

 // å·¥å…·å®šä¹‰è¯¦ç»†ä¿¡æ¯
 public class ToolDefinition
 {
     public string Name { get; init; }
     public string Description { get; init; }
     public string Category { get; init; } = "General";
     public string Version { get; init; } = "1.0.0";

     public List<ToolParameter> Parameters { get; init; } = new();
     public ToolReturnType ReturnType { get; init; }

     // å®‰å…¨è®¾ç½®
     public bool RequiresConfirmation { get; init; }
     public bool RequiresAuthentication { get; init; }
     public string[] RequiredRoles { get; init; } = Array.Empty<string>();
     public string[] RequiredPermissions { get; init; } = Array.Empty<string>();

     // æ‰§è¡Œè®¾ç½®
     public TimeSpan Timeout { get; init; } = TimeSpan.FromSeconds(30);
     public int MaxRetryCount { get; init; } = 0;
     public bool AllowParallelExecution { get; init; } = true;

     // å…ƒæ•°æ®
     public Dictionary<string, object> Metadata { get; init; } = new();
     public Dictionary<string, string> Tags { get; init; } = new();
 }

 // å·¥å…·å‚æ•°å®šä¹‰
 public class ToolParameter
 {
     public string Name { get; init; }
     public string Type { get; init; }
     public string Description { get; init; }
     public bool Required { get; init; }
     public object DefaultValue { get; init; }
     public List<ValidationRule> ValidationRules { get; init; } = new();
     public Dictionary<string, object> Constraints { get; init; } = new();
 }

 // éªŒè¯è§„åˆ™
 public class ValidationRule
 {
     public string Type { get; init; } // "range", "length", "regex", "custom"
     public object Constraint { get; init; }
     public string ErrorMessage { get; init; }
     public Func<object, bool> CustomValidator { get; init; }
 }

 // å·¥å…·æ‰§è¡Œç»“æœ
 public class ToolResult
 {
     public bool Success { get; init; }
     public object Data { get; init; }
     public string ErrorMessage { get; init; }
     public List<ValidationError> ValidationErrors { get; init; } = new();
     public TimeSpan ExecutionTime { get; init; }
     public Dictionary<string, object> Metadata { get; init; } = new();

     public static ToolResult Success(object data = null) =>
         new() { Success = true, Data = data };

     public static ToolResult Failure(string errorMessage, List<ValidationError> errors = null) =>
         new() { Success = false, ErrorMessage = errorMessage, ValidationErrors = errors ?? new() };
 }
 ```

 ### 2. å·¥å…·ä¸Šä¸‹æ–‡

 ```csharp
 public interface IToolContext
 {
     // æ‰§è¡Œä¸Šä¸‹æ–‡
     string AgentId { get; }
     IServiceProvider ServiceProvider { get; }
     CancellationToken CancellationToken { get; }
     IPrincipal Principal { get; }

     // çŠ¶æ€è®¿é—®
     TState GetAgentState<TState>() where TState : class;
     Task<TState> GetAgentStateAsync<TState>(string agentId) where TState : class;

     // äº‹ä»¶è®¿é—®
     Task PublishEventAsync<TEvent>(TEvent @event, EventDirection direction = EventDirection.Bidirectional);
     Task<List<TEvent>> GetRecentEventsAsync<TEvent>(int count = 10);

     // å†…å­˜è®¿é—®
     Task<List<MemoryItem>> SearchMemoryAsync(string query, int maxResults = 10);
     Task StoreInMemoryAsync(MemoryItem item);

     // é…ç½®è®¿é—®
     TConfig GetConfiguration<TConfig>() where TConfig : class, new();
     object GetConfiguration(string key);

     // æ—¥å¿—è®°å½•
     void LogInformation(string message, params object[] args);
     void LogWarning(string message, params object[] args);
     void LogError(Exception exception, string message, params object[] args);
 }

 public class ToolContext : IToolContext
 {
     private readonly IAgentRepository _agentRepository;
     private readonly IEventPublisher _eventPublisher;
     private readonly IAevatarMemory _memory;
     private readonly IConfiguration _configuration;
     private readonly ILogger _logger;

     public ToolContext(
         string agentId,
         IServiceProvider serviceProvider,
         IPrincipal principal,
         CancellationToken cancellationToken)
     {
         AgentId = agentId;
         ServiceProvider = serviceProvider;
         Principal = principal;
         CancellationToken = cancellationToken;

         // è§£æä¾èµ–
         _agentRepository = serviceProvider.GetRequiredService<IAgentRepository>();
         _eventPublisher = serviceProvider.GetRequiredService<IEventPublisher>();
         _memory = serviceProvider.GetRequiredService<IAevatarMemory>();
         _configuration = serviceProvider.GetService<IConfiguration>();
         _logger = serviceProvider.GetRequiredService<ILogger<ToolContext>>();
     }

     public TState GetAgentState<TState>() where TState : class
     {
         return _agentRepository.GetAgentState<TState>(AgentId);
     }

     public async Task<TState> GetAgentStateAsync<TState>(string agentId) where TState : class
     {
         return await _agentRepository.GetAgentStateAsync<TState>(agentId);
     }

     public async Task PublishEventAsync<TEvent>(TEvent @event, EventDirection direction = EventDirection.Bidirectional)
     {
         await _eventPublisher.PublishAsync(@event, direction);
     }

     public async Task<List<TEvent>> GetRecentEventsAsync<TEvent>(int count = 10)
     {
         return await _eventPublisher.GetRecentEventsAsync<TEvent>(AgentId, count);
     }

     public async Task<List<MemoryItem>> SearchMemoryAsync(string query, int maxResults = 10)
     {
         return await _memory.SearchLongTermMemoryAsync(AgentId, query, maxResults);
     }

     public async Task StoreInMemoryAsync(MemoryItem item)
     {
         await _memory.StoreInLongTermMemoryAsync(AgentId, item);
     }

     public TConfig GetConfiguration<TConfig>() where TConfig : class, new()
     {
         return _configuration?.Get<TConfig>() ?? new TConfig();
     }

     public object GetConfiguration(string key)
     {
         return _configuration?[key];
     }

     public void LogInformation(string message, params object[] args)
     {
         _logger.LogInformation($"[{AgentId}] {message}", args);
     }

     public void LogWarning(string message, params object[] args)
     {
         _logger.LogWarning($"[{AgentId}] {message}", args);
     }

     public void LogError(Exception exception, string message, params object[] args)
     {
         _logger.LogError(exception, $"[{AgentId}] {message}", args);
     }
 }
 ```

 ### 3. å·¥å…·ç®¡ç†å™¨

 ```csharp
 public interface IAevatarToolManager
 {
     // å·¥å…·æ³¨å†Œ
     Task RegisterToolAsync(IAevatarTool tool);
     Task RegisterToolsAsync(IEnumerable<IAevatarTool> tools);
     Task UnregisterToolAsync(string toolName);
     Task UnregisterToolsAsync(IEnumerable<string> toolNames);

     // å·¥å…·æŸ¥è¯¢
     Task<IAevatarTool> GetToolAsync(string toolName);
     Task<List<IAevatarTool>> GetAllToolsAsync();
     Task<List<IAevatarTool>> GetToolsByCategoryAsync(string category);
     Task<List<IAevatarTool>> GetToolsByTagAsync(string tag);
     Task<bool> ToolExistsAsync(string toolName);

     // å·¥å…·å‘ç°
     Task AutoDiscoverToolsAsync(Assembly assembly = null);
     Task RegisterToolsFromAgentAsync<TAgent>() where TAgent : IAIGAgent;
     Task RegisterToolsFromConfigurationAsync(IConfiguration configuration);

     // å·¥å…·æ‰§è¡Œ
     Task<ToolResult> ExecuteToolAsync(
         string toolName,
         Dictionary<string, object> parameters,
         IToolContext context = null,
         CancellationToken cancellationToken = default);

     Task<List<ToolResult>> ExecuteToolsAsync(
         List<ToolExecutionRequest> requests,
         IToolContext context = null,
         CancellationToken cancellationToken = default);

     // å·¥å…·éªŒè¯
     Task<ValidationResult> ValidateToolAsync(string toolName, Dictionary<string, object> parameters);
     Task<bool> HasPermissionAsync(string toolName, IPrincipal principal, Dictionary<string, object> parameters);

     // äº‹ä»¶å’Œé€šçŸ¥
     event EventHandler<ToolRegisteredEventArgs> ToolRegistered;
     event EventHandler<ToolUnregisteredEventArgs> ToolUnregistered;
     event EventHandler<ToolExecutedEventArgs> ToolExecuted;
 }

 public class AevatarToolManager : IAevatarToolManager
 {
     private readonly ConcurrentDictionary<string, IAevatarTool> _tools;
     private readonly IToolValidator _validator;
     private readonly IToolExecutor _executor;
     private readonly IToolContextFactory _contextFactory;
     private readonly ILogger<AevatarToolManager> _logger;

     public async Task RegisterToolAsync(IAevatarTool tool)
     {
         if (tool == null)
             throw new ArgumentNullException(nameof(tool));

         // éªŒè¯å·¥å…·å®šä¹‰
         var validationResult = await _validator.ValidateToolDefinitionAsync(tool.Definition);
         if (!validationResult.IsValid)
         {
             throw new InvalidToolException($"Tool {tool.Name} validation failed: {validationResult.ErrorMessage}");
         }

         // åˆå§‹åŒ–å·¥å…·
         await tool.InitializeAsync();

         // æ³¨å†Œå·¥å…·
         _tools[tool.Name] = tool;

         _logger.LogInformation("Tool {ToolName} registered successfully", tool.Name);
         ToolRegistered?.Invoke(this, new ToolRegisteredEventArgs(tool));
     }

     public async Task<ToolResult> ExecuteToolAsync(
         string toolName,
         Dictionary<string, object> parameters,
         IToolContext context = null,
         CancellationToken cancellationToken = default)
     {
         if (!_tools.TryGetValue(toolName, out var tool))
         {
             return ToolResult.Failure($"Tool '{toolName}' not found");
         }

         context ??= await _contextFactory.CreateContextAsync(cancellationToken);

         try
         {
             _logger.LogInformation("Executing tool {ToolName} for agent {AgentId}", toolName, context?.AgentId);

             // 1. å‚æ•°éªŒè¯
             var validationResult = await tool.ValidateParametersAsync(parameters);
             if (!validationResult.IsValid)
             {
                 return ToolResult.Failure("Parameter validation failed", validationResult.Errors);
             }

             // 2. æƒé™æ£€æŸ¥
             if (context?.Principal != null)
             {
                 var hasPermission = await tool.HasPermissionAsync(context.Principal, parameters);
                 if (!hasPermission)
                 {
                     return ToolResult.Failure($"Insufficient permissions to execute tool '{toolName}'");
                 }
             }

             // 3. æ‰§è¡Œå·¥å…·
             var result = await _executor.ExecuteAsync(tool, parameters, context, cancellationToken);

             // 4. è®°å½•æ‰§è¡Œ
             ToolExecuted?.Invoke(this, new ToolExecutedEventArgs(tool, result));

             _logger.LogInformation("Tool {ToolName} executed successfully in {ExecutionTime}ms",
                 toolName, result.ExecutionTime.TotalMilliseconds);

             return result;
         }
         catch (Exception ex)
         {
             _logger.LogError(ex, "Tool {ToolName} execution failed", toolName);
             return ToolResult.Failure($"Tool execution failed: {ex.Message}");
         }
     }

     public async Task AutoDiscoverToolsAsync(Assembly assembly = null)
     {
         assembly ??= Assembly.GetExecutingAssembly();

         var toolTypes = assembly.GetTypes()
             .Where(t => typeof(IAevatarTool).IsAssignableFrom(t) && !t.IsAbstract && !t.IsInterface)
             .ToList();

         foreach (var toolType in toolTypes)
         {
             try
             {
                 var tool = ActivatorUtilities.CreateInstance(_serviceProvider, toolType) as IAevatarTool;
                 await RegisterToolAsync(tool);
             }
             catch (Exception ex)
             {
                 _logger.LogWarning(ex, "Failed to auto-register tool {ToolType}", toolType.Name);
             }
         }
     }
 }
 ```

 ## ğŸ› ï¸ å·¥å…·åŸºç±»å®ç°

 ### 1. åŸºç¡€å·¥å…·åŸºç±»

 ```csharp
 public abstract class AevatarToolBase : IAevatarTool
 {
     protected ToolDefinition _definition;
     protected readonly ILogger _logger;

     protected AevatarToolBase(ILogger logger = null)
     {
         _logger = logger ?? NullLogger.Instance;
         InitializeDefinition();
     }

     protected virtual void InitializeDefinition()
     {
         var toolAttribute = GetType().GetCustomAttribute<ToolAttribute>();
         _definition = new ToolDefinition
         {
             Name = toolAttribute?.Name ?? GetType().Name.Replace("Tool", ""),
             Description = toolAttribute?.Description ?? "No description provided",
             Category = toolAttribute?.Category ?? "General",
             Version = toolAttribute?.Version ?? "1.0.0",
             Parameters = new List<ToolParameter>(),
             ReturnType = new ToolReturnType { Type = "object", Description = "Tool execution result" }
         };
     }

     protected void DefineParameter(
         string name,
         string type,
         string description,
         bool required = true,
         object defaultValue = null,
         List<ValidationRule> validationRules = null)
     {
         var parameter = new ToolParameter
         {
             Name = name,
             Type = type,
             Description = description,
             Required = required,
             DefaultValue = defaultValue,
             ValidationRules = validationRules ?? new List<ValidationRule>()
         };

         _definition.Parameters.Add(parameter);
     }

     protected void AddValidationRule(string parameterName, ValidationRule rule)
     {
         var parameter = _definition.Parameters.FirstOrDefault(p => p.Name == parameterName);
         if (parameter != null)
         {
             parameter.ValidationRules.Add(rule);
         }
     }

     public string Name => _definition.Name;
     public string Description => _definition.Description;
     public string Category => _definition.Category;
     public string Version => _definition.Version;
     public ToolDefinition Definition => _definition;

     public virtual async Task InitializeAsync(CancellationToken cancellationToken = default)
     {
         _logger.LogInformation("Initializing tool {ToolName}", Name);
         await Task.CompletedTask;
     }

     public virtual async Task CleanupAsync(CancellationToken cancellationToken = default)
     {
         _logger.LogInformation("Cleaning up tool {ToolName}", Name);
         await Task.CompletedTask;
     }

     public abstract Task<ToolResult> ExecuteAsync(
         Dictionary<string, object> parameters,
         CancellationToken cancellationToken = default);

     public virtual async Task<ValidationResult> ValidateParametersAsync(Dictionary<string, object> parameters)
     {
         var errors = new List<ValidationError>();

         foreach (var parameter in _definition.Parameters)
         {
             var hasValue = parameters.TryGetValue(parameter.Name, out var value);

             // æ£€æŸ¥å¿…éœ€å‚æ•°
             if (parameter.Required && !hasValue)
             {
                 errors.Add(new ValidationError(parameter.Name, $"Parameter '{parameter.Name}' is required"));
                 continue;
             }

             // ä½¿ç”¨é»˜è®¤å€¼
             if (!hasValue && parameter.DefaultValue != null)
             {
                 parameters[parameter.Name] = parameter.DefaultValue;
                 value = parameter.DefaultValue;
             }

             // è·³è¿‡ç©ºå€¼
             if (!hasValue) continue;

             // éªŒè¯å‚æ•°ç±»å‹
             var typeValidation = ValidateParameterType(parameter, value);
             if (!typeValidation.IsValid)
             {
                 errors.AddRange(typeValidation.Errors);
                 continue;
             }

             // éªŒè¯è§„åˆ™
             foreach (var rule in parameter.ValidationRules)
             {
                 var ruleValidation = await ValidateRuleAsync(parameter.Name, value, rule);
                 if (!ruleValidation.IsValid)
                 {
                     errors.AddRange(ruleValidation.Errors);
                 }
             }
         }

         return new ValidationResult(errors.Count == 0, errors);
     }

     public virtual async Task<bool> HasPermissionAsync(IPrincipal principal, Dictionary<string, object> parameters)
     {
         // æ£€æŸ¥è§’è‰²
         if (_definition.RequiredRoles?.Any() == true)
         {
             foreach (var requiredRole in _definition.RequiredRoles)
             {
                 if (!principal.IsInRole(requiredRole))
                 {
                     return false;
                 }
             }
         }

         // æ£€æŸ¥æƒé™
         if (_definition.RequiredPermissions?.Any() == true)
         {
             foreach (var requiredPermission in _definition.RequiredPermissions)
             {
                 if (!await CheckPermissionAsync(principal, requiredPermission, parameters))
                 {
                     return false;
                 }
             }
         }

         return true;
     }

     protected virtual async Task<bool> CheckPermissionAsync(IPrincipal principal, string permission, Dictionary<string, object> parameters)
     {
         // å­ç±»å¯ä»¥é‡å†™ä»¥æä¾›ç‰¹å®šçš„æƒé™æ£€æŸ¥é€»è¾‘
         return true;
     }

     private ValidationResult ValidateParameterType(ToolParameter parameter, object value)
     {
         var errors = new List<ValidationError>();

         try
         {
             var targetType = Type.GetType(parameter.Type) ?? typeof(object);
             var convertedValue = Convert.ChangeType(value, targetType);

             // ç±»å‹è½¬æ¢æˆåŠŸï¼Œæ›´æ–°å‚æ•°å€¼
             if (!ReferenceEquals(convertedValue, value))
             {
                 // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦åœ¨è°ƒç”¨è€…ä¸­æ›´æ–°å‚æ•°å€¼
             }
         }
         catch (Exception ex)
         {
             errors.Add(new ValidationError(parameter.Name, $"Parameter '{parameter.Name}' must be of type {parameter.Type}: {ex.Message}"));
         }

         return new ValidationResult(errors.Count == 0, errors);
     }

     private async Task<ValidationResult> ValidateRuleAsync(string parameterName, object value, ValidationRule rule)
     {
         var errors = new List<ValidationError>();

         switch (rule.Type.ToLower())
         {
             case "range":
                 if (!IsInRange(value, rule.Constraint))
                 {
                     errors.Add(new ValidationError(parameterName, rule.ErrorMessage ?? $"Parameter '{parameterName}' is out of range"));
                 }
                 break;

             case "length":
                 if (!HasValidLength(value, rule.Constraint))
                 {
                     errors.Add(new ValidationError(parameterName, rule.ErrorMessage ?? $"Parameter '{parameterName}' has invalid length"));
                 }
                 break;

             case "regex":
                 if (!MatchesPattern(value, rule.Constraint.ToString()))
                 {
                     errors.Add(new ValidationError(parameterName, rule.ErrorMessage ?? $"Parameter '{parameterName}' does not match required pattern"));
                 }
                 break;

             case "custom":
                 if (rule.CustomValidator != null && !rule.CustomValidator(value))
                 {
                     errors.Add(new ValidationError(parameterName, rule.ErrorMessage ?? $"Parameter '{parameterName}' failed custom validation"));
                 }
                 break;
         }

         await Task.CompletedTask;
         return new ValidationResult(errors.Count == 0, errors);
     }

     private bool IsInRange(object value, object constraint)
     {
         // å®ç°èŒƒå›´éªŒè¯é€»è¾‘
         return true;
     }

     private bool HasValidLength(object value, object constraint)
     {
         // å®ç°é•¿åº¦éªŒè¯é€»è¾‘
         return true;
     }

     private bool MatchesPattern(object value, string pattern)
     {
         if (value is string stringValue)
         {
             return Regex.IsMatch(stringValue, pattern);
         }
         return false;
     }
 }
 ```

 ### 2. å·¥å…·å±æ€§å®šä¹‰

 ```csharp
 [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
 public class ToolAttribute : Attribute
 {
     public string Name { get; }
     public string Description { get; }
     public string Category { get; set; } = "General";
     public string Version { get; set; } = "1.0.0";
     public bool RequiresConfirmation { get; set; } = false;
     public bool RequiresAuthentication { get; set; } = false;
     public string[] RequiredRoles { get; set; } = Array.Empty<string>();
     public string[] RequiredPermissions { get; set; } = Array.Empty<string>();
     public int TimeoutSeconds { get; set; } = 30;
     public int MaxRetryCount { get; set; } = 0;
     public bool AllowParallelExecution { get; set; } = true;

     public ToolAttribute(string name, string description)
     {
         Name = name ?? throw new ArgumentNullException(nameof(name));
         Description = description ?? throw new ArgumentNullException(nameof(description));
     }
 }

 [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
 public class ToolParameterAttribute : Attribute
 {
     public string Name { get; }
     public string Type { get; }
     public string Description { get; }
     public bool Required { get; set; } = true;
     public object DefaultValue { get; set; }

     public ToolParameterAttribute(string name, string type, string description)
     {
         Name = name ?? throw new ArgumentNullException(nameof(name));
         Type = type ?? throw new ArgumentNullException(nameof(type));
         Description = description ?? throw new ArgumentNullException(nameof(description));
     }
 }
 ```

 ## ğŸ›¡ï¸ å®‰å…¨ä¸éªŒè¯

 ### 1. å·¥å…·éªŒè¯å™¨

 ```csharp
 public interface IToolValidator
 {
     Task<ValidationResult> ValidateToolDefinitionAsync(ToolDefinition definition);
     Task<ValidationResult> ValidateParametersAsync(ToolDefinition definition, Dictionary<string, object> parameters);
     Task<ValidationResult> ValidatePermissionsAsync(IPrincipal principal, ToolDefinition definition, Dictionary<string, object> parameters);
 }

 public class ToolValidator : IToolValidator
 {
     private readonly List<IToolValidationRule> _validationRules;

     public ToolValidator()
     {
         _validationRules = new List<IToolValidationRule>
         {
             new ToolNameValidationRule(),
             new ToolParameterValidationRule(),
             new ToolSecurityValidationRule(),
             new ToolTimeoutValidationRule()
         };
     }

     public async Task<ValidationResult> ValidateToolDefinitionAsync(ToolDefinition definition)
     {
         var errors = new List<ValidationError>();

         foreach (var rule in _validationRules)
         {
             var result = await rule.ValidateAsync(definition);
             if (!result.IsValid)
             {
                 errors.AddRange(result.Errors);
             }
         }

         return new ValidationResult(errors.Count == 0, errors);
     }

     public async Task<ValidationResult> ValidateParametersAsync(ToolDefinition definition, Dictionary<string, object> parameters)
     {
         var errors = new List<ValidationError>();

         // éªŒè¯å¿…éœ€å‚æ•°
         var requiredParameters = definition.Parameters.Where(p => p.Required).Select(p => p.Name).ToList();
         var missingParameters = requiredParameters.Except(parameters.Keys).ToList();

         if (missingParameters.Any())
         {
             errors.AddRange(missingParameters.Select(param =>
                 new ValidationError(param, $"Required parameter '{param}' is missing")));
         }

         // éªŒè¯å‚æ•°ç±»å‹å’Œçº¦æŸ
         foreach (var parameter in definition.Parameters)
         {
             if (parameters.TryGetValue(parameter.Name, out var value))
             {
                 var paramErrors = await ValidateParameterValueAsync(parameter, value);
                 errors.AddRange(paramErrors);
             }
         }

         return new ValidationResult(errors.Count == 0, errors);
     }

     private async Task<List<ValidationError>> ValidateParameterValueAsync(ToolParameter parameter, object value)
     {
         var errors = new List<ValidationError>();

         // ç±»å‹éªŒè¯
         if (!IsValidType(parameter.Type, value))
         {
             errors.Add(new ValidationError(parameter.Name, $"Parameter '{parameter.Name}' must be of type {parameter.Type}"));
             return errors;
         }

         // çº¦æŸéªŒè¯
         foreach (var constraint in parameter.Constraints)
         {
             var constraintErrors = await ValidateConstraintAsync(parameter, value, constraint);
             errors.AddRange(constraintErrors);
         }

         // éªŒè¯è§„åˆ™
         foreach (var rule in parameter.ValidationRules)
         {
             var ruleErrors = await ValidateRuleAsync(parameter, value, rule);
             errors.AddRange(ruleErrors);
         }

         await Task.CompletedTask;
         return errors;
     }
 }
 ```

 ### 2. è®¿é—®æ§åˆ¶

 ```csharp
 public interface IToolAccessControl
 {
     Task<bool> CanExecuteToolAsync(IPrincipal principal, string toolName, Dictionary<string, object> parameters);
     Task<List<string>> GetAllowedToolsAsync(IPrincipal principal);
     Task<List<string>> GetDeniedToolsAsync(IPrincipal principal);
     Task GrantToolAccessAsync(IPrincipal principal, string toolName);
     Task RevokeToolAccessAsync(IPrincipal principal, string toolName);
 }

 public class ToolAccessControl : IToolAccessControl
 {
     private readonly IToolPermissionStore _permissionStore;
     private readonly IToolAuditLogger _auditLogger;

     public async Task<bool> CanExecuteToolAsync(IPrincipal principal, string toolName, Dictionary<string, object> parameters)
     {
         var userId = principal.Identity?.Name;
         if (string.IsNullOrEmpty(userId))
         {
             return false;
         }

         // æ£€æŸ¥å…¨å±€æƒé™
         var hasGlobalPermission = await _permissionStore.HasGlobalPermissionAsync(userId, toolName);
         if (hasGlobalPermission)
         {
             await _auditLogger.LogAccessGrantedAsync(userId, toolName, parameters);
             return true;
         }

         // æ£€æŸ¥å‚æ•°ç‰¹å®šæƒé™
         var hasParameterPermission = await _permissionStore.HasParameterPermissionAsync(userId, toolName, parameters);
         if (hasParameterPermission)
         {
             await _auditLogger.LogAccessGrantedAsync(userId, toolName, parameters);
             return true;
         }

         await _auditLogger.LogAccessDeniedAsync(userId, toolName, parameters, "Insufficient permissions");
         return false;
     }
 }
 ```

 ## âš¡ æ‰§è¡Œå¼•æ“

 ### 1. å·¥å…·æ‰§è¡Œå™¨

 ```csharp
 public interface IToolExecutor
 {
     Task<ToolResult> ExecuteAsync(
         IAevatarTool tool,
         Dictionary<string, object> parameters,
         IToolContext context = null,
         CancellationToken cancellationToken = default);

     Task<List<ToolResult>> ExecuteBatchAsync(
         List<ToolExecutionRequest> requests,
         IToolContext context = null,
         CancellationToken cancellationToken = default);
 }

 public class ToolExecutor : IToolExecutor
 {
     private readonly IToolRetryPolicy _retryPolicy;
     private readonly IToolCircuitBreaker _circuitBreaker;
     private readonly IToolRateLimiter _rateLimiter;
     private readonly IToolTimeoutManager _timeoutManager;

     public async Task<ToolResult> ExecuteAsync(
         IAevatarTool tool,
         Dictionary<string, object> parameters,
         IToolContext context = null,
         CancellationToken cancellationToken = default)
     {
         var stopwatch = Stopwatch.StartNew();

         try
         {
             // 1. é€Ÿç‡é™åˆ¶æ£€æŸ¥
             await _rateLimiter.CheckRateLimitAsync(tool.Name);

             // 2. ç†”æ–­å™¨æ£€æŸ¥
             if (!_circuitBreaker.CanExecute(tool.Name))
             {
                 return ToolResult.Failure($"Tool '{tool.Name}' is currently unavailable due to circuit breaker");
             }

             // 3. åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
             var executionContext = CreateExecutionContext(tool, parameters, context);

             // 4. è®¾ç½®è¶…æ—¶
             using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
             var timeout = tool.Definition.Timeout;
             timeoutCts.CancelAfter(timeout);

             // 5. æ‰§è¡Œå·¥å…·ï¼ˆå¸¦é‡è¯•ï¼‰
             var result = await ExecuteWithRetryAsync(tool, parameters, executionContext, timeoutCts.Token);

             stopwatch.Stop();

             // 6. è®°å½•æˆåŠŸæ‰§è¡Œ
             await _circuitBreaker.RecordSuccessAsync(tool.Name);

             // 7. æ›´æ–°æ‰§è¡Œæ—¶é—´
             result = new ToolResult
             {
                 Success = result.Success,
                 Data = result.Data,
                 ErrorMessage = result.ErrorMessage,
                 ValidationErrors = result.ValidationErrors,
                 ExecutionTime = stopwatch.Elapsed,
                 Metadata = result.Metadata
             };

             return result;
         }
         catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
         {
             return ToolResult.Failure($"Tool '{tool.Name}' execution was cancelled");
         }
         catch (OperationCanceledException)
         {
             return ToolResult.Failure($"Tool '{tool.Name}' execution timed out after {tool.Definition.Timeout.TotalSeconds} seconds");
         }
         catch (Exception ex)
         {
             stopwatch.Stop();

             // è®°å½•å¤±è´¥
             await _circuitBreaker.RecordFailureAsync(tool.Name);

             _logger.LogError(ex, "Tool '{ToolName}' execution failed", tool.Name);
             return ToolResult.Failure($"Tool execution failed: {ex.Message}");
         }
     }

     private async Task<ToolResult> ExecuteWithRetryAsync(
         IAevatarTool tool,
         Dictionary<string, object> parameters,
         IToolContext context,
         CancellationToken cancellationToken)
     {
         var retryPolicy = _retryPolicy.GetRetryPolicy(tool.Definition.MaxRetryCount);

         return await retryPolicy.ExecuteAsync(async () =>
         {
             return await tool.ExecuteAsync(parameters, cancellationToken);
         });
     }
 }
 ```

 ### 2. æ‰¹å¤„ç†æ‰§è¡Œ

 ```csharp
 public class BatchToolExecutor : IToolExecutor
 {
     private readonly IToolExecutor _individualExecutor;
     private readonly IBatchExecutionStrategy _batchStrategy;

     public async Task<List<ToolResult>> ExecuteBatchAsync(
         List<ToolExecutionRequest> requests,
         IToolContext context = null,
         CancellationToken cancellationToken = default)
     {
         // åˆ†ç»„è¯·æ±‚ä»¥ä¼˜åŒ–æ‰§è¡Œ
         var executionGroups = _batchStrategy.GroupRequests(requests);

         var results = new List<ToolResult>();

         // å¹¶è¡Œæ‰§è¡Œç»„
         var tasks = executionGroups.Select(async group =>
         {
             if (group.CanExecuteInParallel)
             {
                 // å¹¶è¡Œæ‰§è¡Œ
                 var parallelResults = await ExecuteParallelAsync(group, context, cancellationToken);
                 return parallelResults;
             }
             else
             {
                 // é¡ºåºæ‰§è¡Œ
                 var sequentialResults = await ExecuteSequentialAsync(group, context, cancellationToken);
                 return sequentialResults;
             }
         });

         var groupResults = await Task.WhenAll(tasks);

         // å±•å¹³ç»“æœå¹¶ä¿æŒåŸå§‹é¡ºåº
         foreach (var groupResult in groupResults)
         {
             results.AddRange(groupResult);
         }

         return results;
     }

     private async Task<List<ToolResult>> ExecuteParallelAsync(
         ExecutionGroup group,
         IToolContext context,
         CancellationToken cancellationToken)
     {
         var results = new ConcurrentBag<(ToolResult, int)>();

         var parallelOptions = new ParallelOptions
         {
             MaxDegreeOfParallelism = group.MaxParallelism,
             CancellationToken = cancellationToken
         };

         await Parallel.ForEachAsync(group.Requests, parallelOptions, async (request, ct) =>
         {
             var result = await _individualExecutor.ExecuteAsync(
                 request.Tool,
                 request.Parameters,
                 context,
                 ct);

             results.Add((result, request.Index));
         });

         // æŒ‰åŸå§‹ç´¢å¼•æ’åº
         return results.OrderBy(x => x.Item2).Select(x => x.Item1).ToList();
     }
 }
 ```

 ## ğŸ“Š å·¥å…·ç›‘æ§ä¸åº¦é‡

 ### 1. å·¥å…·ä½¿ç”¨æŒ‡æ ‡

 ```csharp
 public interface IToolMetricsCollector
 {
     void RecordToolExecution(string toolName, TimeSpan duration, bool success);
     void RecordToolError(string toolName, string errorType);
     void RecordToolTimeout(string toolName);
     void RecordToolRetry(string toolName, int retryCount);
     void RecordToolRateLimitHit(string toolName);
     void RecordToolCircuitBreakerOpen(string toolName);
 }

 public class ToolMetricsCollector : IToolMetricsCollector
 {
     private readonly IMetrics _metrics;

     public void RecordToolExecution(string toolName, TimeSpan duration, bool success)
     {
         var tags = new Dictionary<string, string>
         {
             ["tool_name"] = toolName,
             ["success"] = success.ToString()
         };

         _metrics.IncrementCounter("tools.executions", tags);
         _metrics.RecordHistogram("tools.execution_duration_ms", duration.TotalMilliseconds, tags);
     }

     public void RecordToolError(string toolName, string errorType)
     {
         var tags = new Dictionary<string, string>
         {
             ["tool_name"] = toolName,
             ["error_type"] = errorType
         };

         _metrics.IncrementCounter("tools.errors", tags);
     }
 }
 ```

 ### 2. å·¥å…·å®¡è®¡æ—¥å¿—

 ```csharp
 public interface IToolAuditLogger
 {
     Task LogToolExecutionAsync(string toolName, Dictionary<string, object> parameters, ToolResult result, IPrincipal principal);
     Task LogToolAccessDeniedAsync(string toolName, Dictionary<string, object> parameters, IPrincipal principal, string reason);
     Task LogToolValidationFailedAsync(string toolName, Dictionary<string, object> parameters, List<ValidationError> errors);
     Task LogToolRateLimitedAsync(string toolName, IPrincipal principal);
 }

 public class ToolAuditLogger : IToolAuditLogger
 {
     private readonly ILogger<ToolAuditLogger> _logger;
     private readonly IToolAuditStore _auditStore;

     public async Task LogToolExecutionAsync(string toolName, Dictionary<string, object> parameters, ToolResult result, IPrincipal principal)
     {
         var auditEntry = new ToolAuditEntry
         {
             Timestamp = DateTime.UtcNow,
             ToolName = toolName,
             UserId = principal.Identity?.Name ?? "anonymous",
             Parameters = SanitizeParameters(parameters),
             Success = result.Success,
             ErrorMessage = result.ErrorMessage,
             ExecutionTime = result.ExecutionTime
         };

         // å­˜å‚¨å®¡è®¡è®°å½•
         await _auditStore.StoreAsync(auditEntry);

         // è®°å½•æ—¥å¿—
         _logger.LogInformation("Tool execution: {ToolName} by {UserId} - Success: {Success}, Duration: {Duration}ms",
             toolName, auditEntry.UserId, result.Success, result.ExecutionTime.TotalMilliseconds);
     }

     private Dictionary<string, object> SanitizeParameters(Dictionary<string, object> parameters)
     {
         // ç§»é™¤æ•æ„Ÿä¿¡æ¯
         var sanitized = new Dictionary<string, object>();
         foreach (var param in parameters)
         {
             if (IsSensitiveParameter(param.Key))
             {
                 sanitized[param.Key] = "***REDACTED***";
             }
             else
             {
                 sanitized[param.Key] = param.Value;
             }
         }
         return sanitized;
     }

     private bool IsSensitiveParameter(string parameterName)
     {
         var sensitivePatterns = new[] { "password", "token", "secret", "key", "auth" };
         return sensitivePatterns.Any(pattern => parameterName.ToLower().Contains(pattern));
     }
 }
 ```

 ## ğŸ”§ å·¥å…·å¼€å‘æœ€ä½³å®è·µ

 ### 1. å·¥å…·å®ç°æ¨¡æ¿

 ```csharp
 [Tool("DataValidator", "Validates data against specified rules")]
 public class DataValidatorTool : AevatarToolBase
 {
     public DataValidatorTool(ILogger<DataValidatorTool> logger) : base(logger)
     {
         // âœ… å¥½çš„å·¥å…·è®¾è®¡

         // 1. æ¸…æ™°çš„å·¥å…·å®šä¹‰
         DefineParameter("data", "object", "Data to validate", required: true);
         DefineParameter("rules", "array", "Validation rules to apply", required: true);
         DefineParameter("strict", "boolean", "Enable strict validation", required: false, defaultValue: false);

         // 2. å®Œå–„çš„å‚æ•°éªŒè¯
         AddValidationRule("rules", new ValidationRule
         {
             Type = "custom",
             CustomValidator = rules =>
             {
                 if (rules is not List<object> ruleList) return false;
                 return ruleList.All(rule => rule is Dictionary<string, object>);
             },
             ErrorMessage = "Rules must be an array of rule objects"
         });

         // 3. åˆç†çš„è¶…æ—¶è®¾ç½®
         _definition.Timeout = TimeSpan.FromSeconds(10);
         _definition.MaxRetryCount = 0; // éªŒè¯æ“ä½œä¸é‡è¯•
         _definition.RequiresConfirmation = false; // å®‰å…¨æ“ä½œä¸éœ€è¦ç¡®è®¤
     }

     public override async Task<ToolResult> ExecuteAsync(Dictionary<string, object> parameters, CancellationToken cancellationToken = default)
     {
         try
         {
             var data = parameters["data"];
             var rules = parameters["rules"] as List<object>;
             var strict = Convert.ToBoolean(parameters.GetValueOrDefault("strict", false));

             // 4. è¯¦ç»†çš„æ‰§è¡Œé€»è¾‘
             var validationResults = new List<ValidationResult>();
             var errors = new List<string>();

             foreach (var ruleObj in rules)
             {
                 if (ruleObj is Dictionary<string, object> rule)
                 {
                     try
                     {
                         var result = await ApplyValidationRuleAsync(data, rule, strict, cancellationToken);
                         validationResults.Add(result);
                     }
                     catch (Exception ex)
                     {
                         errors.Add($"Error applying rule {rule.GetValueOrDefault("name")}: {ex.Message}");
                     }
                 }
             }

             // 5. ä¸°å¯Œçš„ç»“æœè¿”å›
             return ToolResult.Success(new
             {
                 isValid = !validationResults.Any(r => !r.IsValid),
                 validationResults,
                 errors,
                 summary = new
                 {
                     totalRules = rules.Count,
                     passedRules = validationResults.Count(r => r.IsValid),
                     failedRules = validationResults.Count(r => !r.IsValid),
                     hasErrors = errors.Any()
                 }
             });
         }
         catch (Exception ex)
         {
             // 6. è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
             return ToolResult.Failure($"Data validation failed: {ex.Message}", new List<ValidationError>
             {
                 new ValidationError("execution", ex.Message)
             });
         }
     }

     private async Task<ValidationResult> ApplyValidationRuleAsync(object data, Dictionary<string, object> rule, bool strict, CancellationToken cancellationToken)
     {
         var ruleName = rule.GetValueOrDefault("name")?.ToString() ?? "unnamed";
         var ruleType = rule.GetValueOrDefault("type")?.ToString();

         return ruleType?.ToLower() switch
         {
             "required" => ValidateRequired(data, rule),
             "range" => ValidateRange(data, rule),
             "pattern" => ValidatePattern(data, rule),
             "custom" => await ValidateCustomAsync(data, rule, cancellationToken),
             _ => new ValidationResult { IsValid = !strict, RuleName = ruleName, Message = $"Unknown rule type: {ruleType}" }
         };
     }
 }
 ```

 ### 2. å·¥å…·æµ‹è¯•æ¨¡æ¿

 ```csharp
 [TestClass]
 public class DataValidatorToolTests
 {
     private DataValidatorTool _tool;
     private Mock<ILogger<DataValidatorTool>> _loggerMock;

     [TestInitialize]
     public void Setup()
     {
         _loggerMock = new Mock<ILogger<DataValidatorTool>>();
         _tool = new DataValidatorTool(_loggerMock.Object);
     }

     [TestMethod]
     public async Task ExecuteAsync_ValidInput_ReturnsSuccess()
     {
         // Arrange
         var parameters = new Dictionary<string, object>
         {
             ["data"] = new { name = "test", value = 42 },
             ["rules"] = new List<object>
             {
                 new Dictionary<string, object>
                 {
                     ["name"] = "required_name",
                     ["type"] = "required",
                     ["field"] = "name"
                 }
             }
         };

         // Act
         var result = await _tool.ExecuteAsync(parameters, CancellationToken.None);

         // Assert
         Assert.IsTrue(result.Success);
         Assert.IsNotNull(result.Data);
     }

     [TestMethod]
     public async Task ExecuteAsync_MissingInput_ReturnsFailure()
     {
         // Arrange
         var parameters = new Dictionary<string, object>
         {
             ["rules"] = new List<object>
             {
                 new Dictionary<string, object>
                 {
                     ["name"] = "required_name",
                     ["type"] = "required",
                     ["field"] = "name"
                 }
             }
         };

         // Act
         var result = await _tool.ExecuteAsync(parameters, CancellationToken.None);

         // Assert
         Assert.IsFalse(result.Success);
         Assert.IsTrue(result.ErrorMessage.Contains("required"));
     }

     [TestMethod]
     public async Task ValidateParametersAsync_ValidParameters_ReturnsValid()
     {
         // Arrange
         var parameters = new Dictionary<string, object>
         {
             ["data"] = new { name = "test", value = 42 },
             ["rules"] = new List<object>
             {
                 new Dictionary<string, object>
                 {
                     ["name"] = "required_name",
                     ["type"] = "required",
                     ["field"] = "name"
                 }
             }
         };

         // Act
         var result = await _tool.ValidateParametersAsync(parameters);

         // Assert
         Assert.IsTrue(result.IsValid);
         Assert.AreEqual(0, result.Errors.Count);
     }
 }
 ```

 ## ğŸ“š æ€»ç»“

 å·¥å…·ç³»ç»Ÿæ˜¯Aevatar Agent Frameworkçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œæä¾›äº†ï¼š

 1. **å®‰å…¨çš„å·¥å…·æ‰§è¡Œç¯å¢ƒ**ï¼šå¤šå±‚éªŒè¯ã€æƒé™æ§åˆ¶ã€å®¡è®¡æ—¥å¿—
 2. **çµæ´»çš„å·¥å…·ç®¡ç†æœºåˆ¶**ï¼šåŠ¨æ€æ³¨å†Œã€è‡ªåŠ¨å‘ç°ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†
 3. **é«˜æ€§èƒ½çš„æ‰§è¡Œå¼•æ“**ï¼šæ‰¹å¤„ç†ã€å¹¶è¡Œæ‰§è¡Œã€å®¹é”™æœºåˆ¶
 4. **å®Œå–„çš„ç›‘æ§ä½“ç³»**ï¼šæŒ‡æ ‡æ”¶é›†ã€æ€§èƒ½è¿½è¸ªã€å¼‚å¸¸å¤„ç†
 5. **ä¸°å¯Œçš„æ‰©å±•èƒ½åŠ›**ï¼šè‡ªå®šä¹‰å·¥å…·ã€æ’ä»¶ç³»ç»Ÿã€é…ç½®ç®¡ç†

 é€šè¿‡éµå¾ªè¿™äº›è®¾è®¡åŸåˆ™å’Œæœ€ä½³å®è·µï¼Œå¯ä»¥æ„å»ºå‡ºæ—¢å®‰å…¨åˆé«˜æ•ˆçš„å·¥å…·ç³»ç»Ÿï¼Œä¸ºAIä»£ç†æä¾›å¼ºå¤§çš„å¤–éƒ¨èƒ½åŠ›æ”¯æŒã€‚

 ---

 *æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†å·¥å…·ç³»ç»Ÿçš„è®¾è®¡ï¼ŒåŒ…æ‹¬æ ¸å¿ƒæ¥å£ã€å®‰å…¨æœºåˆ¶ã€æ‰§è¡Œå¼•æ“å’Œæœ€ä½³å®è·µï¼Œä¸ºå¼€å‘å’Œæ‰©å±•å·¥å…·åŠŸèƒ½æä¾›å…¨é¢æŒ‡å¯¼ã€‚*
